<?php

declare(strict_types=1);

namespace Mainick\KeycloakClientBundle\EventSubscriber;

use Mainick\KeycloakClientBundle\Annotation\ExcludeTokenValidationAttribute;
use Mainick\KeycloakClientBundle\Interface\IamClientInterface;
use Mainick\KeycloakClientBundle\Token\AccessToken;
use Psr\Log\LoggerInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\RequestEvent;
use Symfony\Component\HttpKernel\KernelEvents;

final readonly class TokenAuthListener implements EventSubscriberInterface
{
    public function __construct(
        private LoggerInterface $keycloakClientLogger,
        private IamClientInterface $iamClient
    ) {
    }

    public static function getSubscribedEvents(): array
    {
        return [
            KernelEvents::REQUEST => 'checkValidToken',
        ];
    }

    public function checkValidToken(RequestEvent $requestEvent): void
    {
        if (!$requestEvent->isMainRequest()) {
            return;
        }

        $request = $requestEvent->getRequest();
        $route = $request->attributes->get('_route');

        // Check if the route belongs to the API documentation generated by nelmio/api-doc-bundle
        // Check if the route belongs to the Controller generated by mainick/keycloak-client-bundle
        if (in_array($route, ['app.swagger', 'app.swagger_ui']) || str_starts_with($route, 'mainick_keycloak_security_auth_')) {
            return;
        }

        // Check if the method has the ExcludeTokenValidationAttribute attribute
        $controller = $request->attributes->get('_controller');
        if ($controller) {
            if ($controller instanceof \Closure) {
                return;
            }
            [$controllerClass, $controllerMethod] = explode('::', $controller);
            $reflectionMethod = new \ReflectionMethod($controllerClass, $controllerMethod);
            if ($reflectionMethod->getAttributes(ExcludeTokenValidationAttribute::class)) {
                return;
            }
        }

        $jwtToken = $request->headers->get('X-Auth-Token');
        if (!$jwtToken) {
            $this->keycloakClientLogger->error('Token not found');
            $requestEvent->setResponse(new JsonResponse(['message' => 'Token not found'], Response::HTTP_UNAUTHORIZED));

            return;
        }

        $token = new AccessToken();
        $token->setToken($jwtToken);
        $token->setRefreshToken('');
        $token->setExpires(time() + 3600);
        $userInfo = $this->iamClient->userInfo($token);
        if (!$userInfo) {
            $this->keycloakClientLogger->error('Token not valid');
            $requestEvent->setResponse(new JsonResponse(['message' => 'Token not valid'], Response::HTTP_UNAUTHORIZED));

            return;
        }

        $request->attributes->set('user', $userInfo);
    }
}
